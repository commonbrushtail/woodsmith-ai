---
phase: 05-variation-crud-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/validations/variations.js
  - src/lib/actions/variations.js
autonomous: true

must_haves:
  truths:
    - "Admin can create a variation group with a name via server action"
    - "Admin can add entries to a variation group with label and optional swatch image"
    - "Admin can edit a variation group name and modify existing entries"
    - "Admin can delete a variation group with warning if linked to products"
    - "Admin can reorder entries within a variation group"
  artifacts:
    - path: "src/lib/validations/variations.js"
      provides: "Zod schemas for variation group and entry validation"
      exports: ["variationGroupSchema", "variationEntrySchema"]
    - path: "src/lib/actions/variations.js"
      provides: "Server actions for full variation CRUD"
      exports: ["getVariationGroups", "getVariationGroup", "createVariationGroup", "updateVariationGroup", "deleteVariationGroup", "createVariationEntry", "updateVariationEntry", "deleteVariationEntry", "reorderVariationEntries", "uploadVariationSwatchImage"]
  key_links:
    - from: "src/lib/actions/variations.js"
      to: "src/lib/validations/variations.js"
      via: "import validation schemas"
      pattern: "import.*from.*validations/variations"
    - from: "src/lib/actions/variations.js"
      to: "src/lib/supabase/admin.js"
      via: "createServiceClient for all writes"
      pattern: "createServiceClient"
    - from: "src/lib/actions/variations.js"
      to: "src/lib/storage.js"
      via: "uploadFile/deleteFile for swatch images"
      pattern: "uploadFile|deleteFile|getPublicUrl"
    - from: "src/lib/actions/variations.js"
      to: "src/lib/audit.js"
      via: "logAudit for all mutations"
      pattern: "logAudit"
    - from: "src/lib/actions/variations.js"
      to: "variation_groups table"
      via: "supabase.from('variation_groups')"
      pattern: "from\\('variation_groups'\\)"
    - from: "src/lib/actions/variations.js"
      to: "variation_entries table"
      via: "supabase.from('variation_entries')"
      pattern: "from\\('variation_entries'\\)"
    - from: "src/lib/actions/variations.js"
      to: "product_variation_links table"
      via: "supabase.from('product_variation_links') for delete safety check"
      pattern: "from\\('product_variation_links'\\)"
---

<objective>
Create Zod validation schemas and server actions for full CRUD operations on variation groups and entries, including swatch image upload, reorder, and delete-safety checks.

Purpose: Phase 6 (Variation Admin UI) needs these server actions to wire up the admin pages. This phase delivers the complete data layer for managing variations.

Output: Two files -- `src/lib/validations/variations.js` (Zod schemas) and `src/lib/actions/variations.js` (10 server actions covering all variation CRUD).
</objective>

<execution_context>
@C:/Users/commo/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/commo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-database-infrastructure/04-01-SUMMARY.md

# Schema reference (tables these actions target)
@supabase/migrations/013_variation_tables.sql

# Pattern references (follow these conventions exactly)
@src/lib/actions/categories.js
@src/lib/actions/gallery.js
@src/lib/actions/products.js
@src/lib/validations/categories.js
@src/lib/validations/products.js

# Utilities used by actions
@src/lib/supabase/admin.js
@src/lib/storage.js
@src/lib/upload-validation.js
@src/lib/audit.js
@src/lib/sanitize.js
@src/lib/reorder.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod validation schemas for variations</name>
  <files>src/lib/validations/variations.js</files>
  <action>
Create Zod validation schemas following the exact pattern in `src/lib/validations/categories.js`.

**variationGroupSchema** (for create):
- `name`: `z.string().min(1, 'กรุณาระบุชื่อกลุ่มตัวเลือก')` -- required, Thai error message

**variationGroupUpdateSchema**: `variationGroupSchema.partial()` -- for partial updates

**variationEntrySchema** (for create):
- `label`: `z.string().min(1, 'กรุณาระบุชื่อตัวเลือก')` -- required, Thai error message
- `group_id`: `z.string().uuid('รหัสกลุ่มไม่ถูกต้อง')` -- required UUID reference
- `image_url`: `z.string().url().nullable().optional()` -- optional swatch image URL
- `sort_order`: `z.number().int().optional()` -- optional, auto-assigned if omitted

**variationEntryUpdateSchema**: `variationEntrySchema.partial().omit({ group_id: true })` -- group_id is immutable after creation

Import Zod with `import { z } from 'zod'` (same as existing validation files).
  </action>
  <verify>
Run: `node -e "const v = require('./src/lib/validations/variations.js'); console.log(Object.keys(v))"` -- should list all 4 schema exports.

If ESM import fails, verify file exports are correct by checking: `grep 'export' src/lib/validations/variations.js`
  </verify>
  <done>
File exports variationGroupSchema, variationGroupUpdateSchema, variationEntrySchema, and variationEntryUpdateSchema. Schemas validate correctly: empty name rejects, valid name accepts, entry requires label + group_id UUID.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create server actions for variation CRUD operations</name>
  <files>src/lib/actions/variations.js</files>
  <action>
Create `'use server'` action file following the exact patterns in `src/lib/actions/categories.js` (CRUD + reorder) and `src/lib/actions/products.js` (image upload). All mutations use `createServiceClient()` (service role, bypasses RLS).

**Imports:**
```js
'use server'

import { revalidatePath } from 'next/cache'
import { createClient } from '@/lib/supabase/server'
import { createServiceClient } from '@/lib/supabase/admin'
import { uploadFile, deleteFile, getPublicUrl } from '@/lib/storage'
import { variationGroupSchema, variationGroupUpdateSchema, variationEntrySchema, variationEntryUpdateSchema } from '@/lib/validations/variations'
import { sanitizeInput } from '@/lib/sanitize'
import { logAudit } from '@/lib/audit'
```

**10 exported functions:**

1. **`getVariationGroups()`** -- Fetch all groups with entry count and linked product count.
   - Query `variation_groups` ordered by `name` ascending.
   - For each group, include `variation_entries(id)` to get entry count.
   - Also query `product_variation_links` to count distinct products linked per group.
   - Return `{ data: [...], error: null }` or `{ data: [], error: message }`.
   - Use a single query: `supabase.from('variation_groups').select('*, variation_entries(id, label, image_url, sort_order)')` then for product counts do a separate query: `supabase.from('product_variation_links').select('group_id, product_id')` and aggregate in JS. This avoids complex nested joins.

2. **`getVariationGroup(id)`** -- Fetch single group with all entries sorted by `sort_order`.
   - Query: `.from('variation_groups').select('*, variation_entries(id, label, image_url, sort_order, created_at)').eq('id', id).single()`
   - Sort entries: `.order('sort_order', { referencedTable: 'variation_entries', ascending: true })`
   - Return `{ data, error }` pattern.

3. **`createVariationGroup(formData)`** -- Create a new group.
   - Extract `name` from formData, sanitize with `sanitizeInput()`.
   - Validate with `variationGroupSchema.safeParse({ name })`.
   - On validation failure, return `{ data: null, fieldErrors: {...}, error: null }` (same pattern as `createCategory`).
   - Insert into `variation_groups`, `.select().single()`.
   - Get current user via `createClient()` then `auth.getUser()`.
   - Call `logAudit({ userId: user?.id, action: 'variation_group.create', targetId: data.id })`.
   - Call `revalidatePath('/admin/variations')`.
   - Return `{ data, error: null }`.

4. **`updateVariationGroup(id, formData)`** -- Update group name.
   - Extract `name` from formData if present, sanitize.
   - Validate with `variationGroupUpdateSchema.safeParse(updates)`.
   - Update `variation_groups` where `id` matches, `.select().single()`.
   - Audit log: `action: 'variation_group.update'`.
   - Revalidate `/admin/variations`.
   - Return `{ data, error }`.

5. **`deleteVariationGroup(id)`** -- Delete group with product-link safety check.
   - FIRST: Check `product_variation_links` for any rows where `group_id = id`.
   - Count distinct `product_id` values.
   - If count > 0, return `{ error: null, warning: true, linkedProductCount: count, message: 'กลุ่มตัวเลือกนี้เชื่อมโยงกับสินค้า {count} รายการ' }` -- caller (UI) must confirm before calling `forceDeleteVariationGroup`.
   - If count === 0 OR if formData includes `force: true`: proceed with deletion.
   - Before deleting group, find all entries with `image_url` and delete swatch images from storage (bucket: `products`, path extracted by splitting on `/products/`).
   - Delete from `variation_groups` (CASCADE will remove entries + links).
   - Audit log: `action: 'variation_group.delete'`.
   - Revalidate `/admin/variations`.

   Actually, simpler pattern: accept an optional `{ force }` second parameter. Default behavior checks links and returns warning. If `force: true`, delete regardless.

   ```js
   export async function deleteVariationGroup(id, { force = false } = {}) {
   ```

6. **`createVariationEntry(formData)`** -- Add entry to a group.
   - Extract `group_id`, `label` from formData, sanitize label.
   - Validate with `variationEntrySchema.safeParse(...)`.
   - Auto-assign `sort_order`: query max sort_order in group, add 1 (same pattern as gallery/categories).
   - Handle optional swatch image: if `formData.get('file')` exists and has size > 0, upload to `products` bucket at path `variations/{group_id}/{Date.now()}.{ext}`, get public URL, set as `image_url`.
   - Insert into `variation_entries`, `.select().single()`.
   - Audit log: `action: 'variation_entry.create'`.
   - Revalidate `/admin/variations`.
   - Return `{ data, error }`.

7. **`updateVariationEntry(id, formData)`** -- Update entry label and/or swatch image.
   - Extract `label` if present, sanitize.
   - Validate with `variationEntryUpdateSchema.safeParse(updates)`.
   - Handle file upload (new swatch): delete old image from storage if exists, upload new one. Follow exact pattern from `updateCategory` in categories.js.
   - Handle image removal: if `formData.get('remove_image') === 'true'`, delete from storage and set `image_url` to null.
   - Update `variation_entries` where `id` matches, `.select().single()`.
   - Audit log: `action: 'variation_entry.update'`.
   - Revalidate `/admin/variations`.

8. **`deleteVariationEntry(id)`** -- Delete a single entry.
   - Fetch entry to get `image_url` and `group_id`.
   - If `image_url` exists, delete swatch from storage (bucket: `products`, extract path after `/products/`).
   - Delete from `variation_entries` (CASCADE removes any product_variation_links for this entry).
   - Audit log: `action: 'variation_entry.delete'`.
   - Revalidate `/admin/variations`.

9. **`reorderVariationEntries(updates)`** -- Batch update sort_order.
   - Accept `Array<{id: string, sort_order: number}>` (same signature as `reorderGalleryItems` and `reorderCategories`).
   - Loop through updates, update each entry's `sort_order` in `variation_entries`.
   - Revalidate `/admin/variations`.
   - Return `{ error: null }` or `{ error: message }`.
   - Follow exact pattern from `reorderGalleryItems` in gallery.js.

10. **`uploadVariationSwatchImage(groupId, formData)`** -- Standalone swatch upload (for use outside create/update flows).
    - Follow exact pattern from `uploadOptionImage` in products.js.
    - Extract file from formData.
    - Upload to `products` bucket at path `variations/{groupId}/{Date.now()}.{ext}`.
    - Return `{ url, error }`.

**Revalidation path:** All mutations call `revalidatePath('/admin/variations')` -- this is the path Phase 6 will use for the variations admin pages.

**Storage bucket:** Use `products` bucket with `variations/` subfolder prefix (consistent with how `uploadOptionImage` uses `products` bucket with `options/` subfolder -- no new bucket needed).

**Error patterns:** Follow exact return signatures from categories.js. All errors return `{ error: message }` or `{ data: null, error: message }`.
  </action>
  <verify>
1. Run `grep -c 'export async function' src/lib/actions/variations.js` -- should output `10`.
2. Run `grep "'use server'" src/lib/actions/variations.js` -- should show the directive.
3. Run `grep 'logAudit' src/lib/actions/variations.js | wc -l` -- should be >= 6 (one per mutation: create/update/delete group, create/update/delete entry).
4. Run `grep 'revalidatePath' src/lib/actions/variations.js | wc -l` -- should be >= 7 (all mutations + reorder).
5. Run `grep 'variationGroupSchema\|variationEntrySchema' src/lib/actions/variations.js` -- should show validation imports being used.
6. Run `npm run lint -- --no-error-on-unmatched-pattern src/lib/actions/variations.js src/lib/validations/variations.js` -- no lint errors.
7. Run `npm run build` -- build succeeds (no import errors, no syntax errors).
  </verify>
  <done>
All 10 server actions are exported and follow project conventions: 'use server' directive, createServiceClient for writes, Zod validation on inputs, sanitizeInput on text fields, logAudit on all mutations, revalidatePath on all mutations, storage upload/delete for swatch images, and delete-safety check on group deletion. Return signatures match existing action patterns ({ data, error }, { error }, { data, fieldErrors, error }).
  </done>
</task>

</tasks>

<verification>
1. `src/lib/validations/variations.js` exists and exports 4 schemas
2. `src/lib/actions/variations.js` exists and exports 10 server actions
3. All server actions use `createServiceClient()` for database writes
4. All mutations include `logAudit()` calls
5. All mutations include `revalidatePath('/admin/variations')`
6. Input validation uses imported Zod schemas
7. Text inputs are sanitized with `sanitizeInput()`
8. Swatch image upload uses `products` bucket with `variations/` path prefix
9. Delete group checks `product_variation_links` before proceeding
10. Reorder follows exact pattern from `reorderGalleryItems`
11. `npm run build` passes
</verification>

<success_criteria>
- Admin can call `createVariationGroup` with a name and get back the created group
- Admin can call `createVariationEntry` with group_id + label + optional file and get back the created entry
- Admin can call `updateVariationGroup` to change a group's name
- Admin can call `updateVariationEntry` to change label or swatch image
- Admin can call `deleteVariationGroup` and receive a warning if products are linked, or delete if none are
- Admin can call `reorderVariationEntries` with an array of {id, sort_order} to reorder entries
- All mutations are audit-logged and revalidate the admin variations path
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-variation-crud-operations/05-01-SUMMARY.md`
</output>
