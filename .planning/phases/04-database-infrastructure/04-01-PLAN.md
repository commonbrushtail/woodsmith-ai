---
phase: 04-database-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/013_variation_tables.sql
  - supabase/migrations/014_variation_rls.sql
autonomous: true

must_haves:
  truths:
    - "variation_groups table exists and accepts inserts with name, created_at, updated_at"
    - "variation_entries table exists with FK to variation_groups, supports label, image_url, sort_order"
    - "product_variation_links junction table exists with FKs to products, variation_groups, and variation_entries"
    - "Deleting a variation_group cascades to its entries and product links"
    - "Deleting a variation_entry cascades to its product links"
    - "Deleting a product cascades to its variation links"
    - "Public/anon users can SELECT from all three variation tables"
    - "Public/anon users cannot INSERT/UPDATE/DELETE variation data"
  artifacts:
    - path: "supabase/migrations/013_variation_tables.sql"
      provides: "Schema for variation_groups, variation_entries, product_variation_links"
      contains: "CREATE TABLE variation_groups"
    - path: "supabase/migrations/014_variation_rls.sql"
      provides: "RLS policies for all three variation tables"
      contains: "ENABLE ROW LEVEL SECURITY"
  key_links:
    - from: "variation_entries.group_id"
      to: "variation_groups.id"
      via: "REFERENCES variation_groups(id) ON DELETE CASCADE"
      pattern: "REFERENCES variation_groups"
    - from: "product_variation_links.product_id"
      to: "products.id"
      via: "REFERENCES products(id) ON DELETE CASCADE"
      pattern: "REFERENCES products"
    - from: "product_variation_links.entry_id"
      to: "variation_entries.id"
      via: "REFERENCES variation_entries(id) ON DELETE CASCADE"
      pattern: "REFERENCES variation_entries"
---

<objective>
Create the database schema and RLS policies for the variation management system: variation_groups, variation_entries, and product_variation_links tables.

Purpose: Provide the data foundation for v1.1 Variations Management — all subsequent phases (CRUD actions, admin UI, product integration) depend on these tables existing.
Output: Two SQL migration files (013 for schema, 014 for RLS) following existing migration conventions.
</objective>

<execution_context>
@C:/Users/commo/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/commo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing migration patterns to follow:
@supabase/migrations/001_initial_schema.sql
@supabase/migrations/002_rls_policies.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create variation tables migration (013)</name>
  <files>supabase/migrations/013_variation_tables.sql</files>
  <action>
Create `supabase/migrations/013_variation_tables.sql` with three tables following the exact conventions from `001_initial_schema.sql`:

**Table 1: variation_groups**
```sql
CREATE TABLE variation_groups (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);
```
- Add `update_updated_at` trigger (same pattern as all other tables: `CREATE TRIGGER variation_groups_updated_at BEFORE UPDATE ON variation_groups FOR EACH ROW EXECUTE FUNCTION update_updated_at();`)
- The `update_updated_at()` function already exists from migration 001 — do NOT recreate it

**Table 2: variation_entries**
```sql
CREATE TABLE variation_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id uuid NOT NULL REFERENCES variation_groups(id) ON DELETE CASCADE,
  label text NOT NULL,
  image_url text,
  sort_order integer NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now()
);
```
- `group_id` is NOT NULL with CASCADE delete (removing a group removes all its entries)
- `image_url` is nullable (optional swatch image)
- `sort_order` for drag-and-drop ordering (matches existing pattern in product_options, gallery_items, etc.)
- Add index: `CREATE INDEX idx_variation_entries_group_id ON variation_entries(group_id);`

**Table 3: product_variation_links**
```sql
CREATE TABLE product_variation_links (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id uuid NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  group_id uuid NOT NULL REFERENCES variation_groups(id) ON DELETE CASCADE,
  entry_id uuid NOT NULL REFERENCES variation_entries(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now()
);
```
- All three FKs are NOT NULL with CASCADE delete
- Add unique constraint: `UNIQUE(product_id, entry_id)` — a product cannot link to the same entry twice
- Add indexes:
  - `CREATE INDEX idx_product_variation_links_product_id ON product_variation_links(product_id);`
  - `CREATE INDEX idx_product_variation_links_group_id ON product_variation_links(group_id);`
  - `CREATE INDEX idx_product_variation_links_entry_id ON product_variation_links(entry_id);`

**File structure:** Use section separators matching 001 pattern (`-- ============================================================`). Add header comment: `-- WoodSmith AI: Variation Management Tables`.

Do NOT add `updated_at` to `variation_entries` or `product_variation_links` — entries are simple records (label + image), and links are just associations. Only `variation_groups` needs `updated_at` since the group name can be edited.
  </action>
  <verify>
Run: `cat supabase/migrations/013_variation_tables.sql` and verify:
1. Three CREATE TABLE statements exist
2. All uuid PKs use `DEFAULT gen_random_uuid()`
3. All FKs use `ON DELETE CASCADE`
4. `variation_groups` has `updated_at` trigger
5. `product_variation_links` has UNIQUE constraint on `(product_id, entry_id)`
6. Indexes exist for all FK columns
  </verify>
  <done>
Migration file 013 exists with variation_groups (id, name, created_at, updated_at + trigger), variation_entries (id, group_id FK, label, image_url, sort_order, created_at + index), and product_variation_links (id, product_id FK, group_id FK, entry_id FK, created_at + unique constraint + indexes). All FKs cascade on delete.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create variation RLS policies migration (014)</name>
  <files>supabase/migrations/014_variation_rls.sql</files>
  <action>
Create `supabase/migrations/014_variation_rls.sql` following the exact pattern from `002_rls_policies.sql`:

**Step 1: Enable RLS on all three tables**
```sql
ALTER TABLE variation_groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE variation_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_variation_links ENABLE ROW LEVEL SECURITY;
```

**Step 2: Public read policies for variation_groups**

Variation groups are always readable (they're a shared catalog, not tied to product publish status):
```sql
CREATE POLICY "Public can read variation groups"
  ON variation_groups FOR SELECT
  TO anon
  USING (true);

CREATE POLICY "Authenticated can read variation groups"
  ON variation_groups FOR SELECT
  TO authenticated
  USING (true);
```

**Step 3: Public read policies for variation_entries**

Entries are always readable (same rationale — shared catalog):
```sql
CREATE POLICY "Public can read variation entries"
  ON variation_entries FOR SELECT
  TO anon
  USING (true);

CREATE POLICY "Authenticated can read variation entries"
  ON variation_entries FOR SELECT
  TO authenticated
  USING (true);
```

**Step 4: Public read policies for product_variation_links**

Links should only be readable when the associated product is published (matches the pattern from product_images and product_options in 002):
```sql
CREATE POLICY "Public can read product variation links"
  ON product_variation_links FOR SELECT
  TO anon
  USING (
    EXISTS (
      SELECT 1 FROM products WHERE products.id = product_variation_links.product_id AND products.published = true
    )
  );

CREATE POLICY "Authenticated can read product variation links"
  ON product_variation_links FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM products WHERE products.id = product_variation_links.product_id AND products.published = true
    )
  );
```

**Important:** No INSERT/UPDATE/DELETE policies are needed for anon or authenticated roles. Admin CRUD uses the service role key (`createServiceClient` from `src/lib/supabase/admin.js`), which bypasses RLS entirely. This matches the existing pattern — see comment at top of 002_rls_policies.sql: "Service role key bypasses RLS entirely."

**File structure:** Use section separators and header comment matching 002 pattern. Add header: `-- WoodSmith AI: Variation Management RLS Policies`.
  </action>
  <verify>
Run: `cat supabase/migrations/014_variation_rls.sql` and verify:
1. All three tables have `ENABLE ROW LEVEL SECURITY`
2. `variation_groups` has anon + authenticated SELECT policies with `USING (true)`
3. `variation_entries` has anon + authenticated SELECT policies with `USING (true)`
4. `product_variation_links` has anon + authenticated SELECT policies that check `products.published = true`
5. No INSERT/UPDATE/DELETE policies exist (service role bypasses RLS)
  </verify>
  <done>
Migration file 014 exists with RLS enabled on all three variation tables. variation_groups and variation_entries allow public read (unrestricted). product_variation_links allows public read only when linked product is published. No write policies needed (service role bypasses RLS for admin operations).
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full phase:

1. **File existence:** Both `013_variation_tables.sql` and `014_variation_rls.sql` exist in `supabase/migrations/`
2. **Schema completeness:** All four requirements covered:
   - DB-01: variation_groups table (013)
   - DB-02: variation_entries table (013)
   - DB-03: product_variation_links junction table (013)
   - DB-04: RLS policies (014)
3. **Referential integrity:** All FKs use ON DELETE CASCADE
4. **Convention compliance:** File naming, section separators, and SQL patterns match existing migrations
5. **No regressions:** Existing tables and policies are not modified
</verification>

<success_criteria>
- Two new migration files exist following project conventions
- variation_groups, variation_entries, and product_variation_links tables are fully defined with correct types, constraints, FKs, indexes, and triggers
- RLS policies grant public read access and rely on service role for admin writes
- All migration SQL is syntactically valid PostgreSQL 14
- Phase 5 (Variation CRUD Operations) can proceed with these tables as the data layer
</success_criteria>

<output>
After completion, create `.planning/phases/04-database-infrastructure/04-01-SUMMARY.md`
</output>
